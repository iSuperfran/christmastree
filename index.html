<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />
  <title>Merry Christmas</title>
  <style>
    /* 纯黑背景 */
    html, body { margin:0; height:100%; background-color: #000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }
    
    /* 底部文字：恢复唯美手写感，位置适中 */
    .caption {
      position: fixed; left: 0; right: 0;
      bottom: 8%;
      text-align: center;
      pointer-events: none; user-select: none;
      z-index: 10;
    }
    .caption span {
      display: inline-block;
      font-size: clamp(30px, 8vw, 64px);
      font-family: "Snell Roundhand", "Brush Script MT", "Segoe Script", cursive;
      color: rgba(255, 245, 230, 0.85); /* 柔和的香槟金 */
      text-shadow: 0 0 15px rgba(255, 200, 100, 0.5);
      transform: rotate(-2deg);
      letter-spacing: 1px;
    }

    /* 顶部提示 */
    .hint {
      position: fixed; top: 15px; left: 0; right: 0;
      text-align: center;
      color: rgba(255,255,255,0.3);
      font-size: 12px;
      font-family: sans-serif;
      pointer-events: none;
    }
  </style>
</head>
<body>

<canvas id="c"></canvas>
<div class="hint">单指拖动旋转 · 双指捏合聚拢/张开散开</div>
<div class="caption"><span>Merry Christmas</span></div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false }); 

  const clamp = (x,a,b) => Math.max(a, Math.min(b, x));
  const rand = (a,b) => a + Math.random() * (b - a);
  const lerp = (a,b,t) => a + (b - a) * t;

  let W, H, cx, cy;
  const DPR = Math.min(2.5, window.devicePixelRatio || 1);

  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W * DPR;
    canvas.height = H * DPR;
    ctx.scale(DPR, DPR);
    cx = W / 2;
    cy = H / 2;
  }
  window.addEventListener('resize', resize);
  resize();

  // ================= 交互状态 =================
  let yaw = 0, pitch = -0.15; 
  let targetYaw = 0, targetPitch = -0.15;
  let scatter = 0, targetScatter = 0; // 0=树(聚拢), 1=星尘(散开)

  // 1. 拖动旋转逻辑
  let isDragging = false, lastX = 0, lastY = 0;
  
  const onDown = (x, y) => { isDragging = true; lastX = x; lastY = y; };
  const onMove = (x, y) => {
    if (!isDragging) return;
    const dx = x - lastX;
    const dy = y - lastY;
    lastX = x; lastY = y;
    // 旋转灵敏度
    targetYaw += dx * 0.006; 
    targetPitch += dy * 0.006;
    targetPitch = clamp(targetPitch, -0.8, 0.4);
  };
  const onUp = () => { isDragging = false; };

  canvas.addEventListener('mousedown', e => onDown(e.clientX, e.clientY));
  window.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
  window.addEventListener('mouseup', onUp);

  canvas.addEventListener('touchstart', e => {
    if(e.touches.length === 1) onDown(e.touches[0].clientX, e.touches[0].clientY);
  }, {passive: false});
  canvas.addEventListener('touchmove', e => {
    if(e.touches.length === 1) { e.preventDefault(); onMove(e.touches[0].clientX, e.touches[0].clientY); }
  }, {passive: false});
  window.addEventListener('touchend', onUp);

  // 2. 滚轮控制 (向下滚=聚拢，向上滚=散开)
  canvas.addEventListener('wheel', e => {
    // e.deltaY > 0 (滚轮向下) -> 我们希望它聚拢吗？通常缩小是聚拢。
    // 为了符合直觉：往回滚(下)是变回树，往外推(上)是散开
    targetScatter += Math.sign(-e.deltaY) * 0.08; 
    targetScatter = clamp(targetScatter, 0, 1);
  }, {passive: true});

  // 3. 双指缩放逻辑 (修正版：捏合=聚拢)
  let initDist = 0, initScatter = 0;
  canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      initDist = Math.hypot(dx, dy);
      initScatter = targetScatter;
    }
  });
  canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const dist = Math.hypot(dx, dy);
      
      // 逻辑修正：
      // dist 变大 (张开) -> delta 正 -> scatter 变大 (散开)
      // dist 变小 (捏合) -> delta 负 -> scatter 变小 (聚拢)
      const delta = (dist - initDist) / 300; 
      
      targetScatter = clamp(initScatter + delta, 0, 1);
      e.preventDefault();
    }
  });

  // ================= 粒子系统 =================
  const N = 2800; // 粒子数
  const particles = [];

  function init() {
    for (let i = 0; i < N; i++) {
      // 螺旋分布
      const t = Math.pow(Math.random(), 0.75); // 稍微更均匀一点，不要全堆在下面
      const h = 320; 
      const maxR = 130;
      const y = -h/2 + t * h; 
      
      const rBase = (1 - t) * maxR;
      // 增加随机性，制造“星尘”的模糊边缘
      const r = rBase + rand(-20, 20) * (1-t*0.5); 
      
      const turns = 6.5; 
      const angle = t * Math.PI * 2 * turns + rand(0, 0.8); // 角度抖动

      const x = Math.cos(angle) * r;
      const z = Math.sin(angle) * r;

      // 散开位置 (球形爆炸效果)
      const sDir = Math.random() * Math.PI * 2;
      const sYDir = rand(-1, 1);
      const sR = rand(200, 500);
      const sx = Math.cos(sDir) * sR;
      const sy = sYDir * sR;
      const sz = Math.sin(sDir) * sR;

      // 0=青蓝(冷), 1=琥珀金(暖)
      const colorMix = 1 - t + rand(-0.2, 0.2); 

      particles.push({
        x, y, z,          
        sx, sy, sz,       
        colorMix: clamp(colorMix, 0, 1),         
        size: rand(0.6, 2.2), // 粒子稍微小一点，显得精致
        blink: rand(0, Math.PI * 2), 
        blinkSpeed: rand(1.5, 4)       
      });
    }
  }
  init();

  // ================= 渲染循环 =================
  function draw() {
    // 缓动
    yaw += (targetYaw - yaw) * 0.1;
    pitch += (targetPitch - pitch) * 0.1;
    scatter += (targetScatter - scatter) * 0.1;
    
    // 自动微旋转
    const autoRot = performance.now() * 0.0002;
    const finalYaw = yaw + autoRot;

    // 清空背景 (纯黑)
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, W, H);

    const pData = [];
    const focal = 850; 
    
    const cy_cos = Math.cos(finalYaw), cy_sin = Math.sin(finalYaw);
    const cx_cos = Math.cos(pitch), cx_sin = Math.sin(pitch);

    for (let i = 0; i < N; i++) {
      const p = particles[i];

      // 插值：scatter 0->1
      // 使用三次方插值让散开动作更柔和
      const s = scatter * scatter * (3 - 2 * scatter);
      
      let px = p.x + (p.sx - p.x) * s;
      let py = p.y + (p.sy - p.y) * s;
      let pz = p.z + (p.sz - p.z) * s;

      // 旋转
      let x1 = px * cy_cos - pz * cy_sin;
      let z1 = pz * cy_cos + px * cy_sin;
      let y2 = py * cx_cos - z1 * cx_sin;
      let z2 = z1 * cx_cos + py * cx_sin;

      const depth = z2 + 650;
      if (depth < 50) continue; 

      const scale = focal / depth;
      const screenX = cx + x1 * scale;
      const screenY = cy + y2 * scale * 1.05;

      const time = performance.now() * 0.001;
      const shimmer = Math.sin(time * p.blinkSpeed + p.blink); 
      
      // 调整亮度：不要太爆，但也别太暗
      // 基础 0.2, 波动 +0.6 -> 最高 0.8
      const alpha = 0.2 + 0.6 * (shimmer * 0.5 + 0.5);

      pData.push({ x: screenX, y: screenY, z: depth, size: p.size * scale, colorMix: p.colorMix, alpha });
    }

    pData.sort((a, b) => b.z - a.z);

    // 使用 Screen 模式：柔和发光，不会像 lighter 那么刺眼
    ctx.globalCompositeOperation = 'screen'; 

    for (let i = 0; i < pData.length; i++) {
      const p = pData[i];
      
      // 颜色调优：更高级的香槟金 和 冰蓝色
      // 暖色: 255, 210, 120 (Warm)
      // 冷色: 120, 220, 255 (Cool)
      const r = Math.floor(lerp(120, 255, p.colorMix));
      const g = Math.floor(lerp(220, 210, p.colorMix));
      const b = Math.floor(lerp(255, 120, p.colorMix));
      
      // 绘制光晕 (虚)
      const glowSize = p.size * 3.5;
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${p.alpha * 0.4})`; // 光晕透明度低一点
      ctx.beginPath();
      ctx.arc(p.x, p.y, glowSize, 0, Math.PI * 2);
      ctx.fill();

      // 绘制核心 (实) - 让点看起来更清晰
      ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha * 0.9})`; // 核心偏白
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * 0.6, 0, Math.PI * 2);
      ctx.fill();
    }

    // 绘制顶部的星 (仅当聚拢时可见)
    if (scatter < 0.9) {
      const topY = -160 - 15; 
      let tx = 0, ty = topY, tz = 0;
      let tx1 = tx * cy_cos - tz * cy_sin;
      let tz1 = tz * cy_cos + tx * cy_sin;
      let ty2 = ty * cx_cos - tz1 * cx_sin;
      let tz2 = tz1 * cx_cos + ty * cx_sin;
      const tDepth = tz2 + 650;
      const tScale = focal / tDepth;
      const tScreenX = cx + tx1 * tScale;
      const tScreenY = cy + ty2 * tScale * 1.05;

      const starAlpha = (1 - smoothstep(0.3, 0.9, scatter)) * 0.9;
      if (starAlpha > 0.01) {
        drawStar(tScreenX, tScreenY, tScale * 18, starAlpha);
      }
    }

    requestAnimationFrame(draw);
  }

  function smoothstep(min, max, value) {
    var x = Math.max(0, Math.min(1, (value-min)/(max-min)));
    return x*x*(3 - 2*x);
  }

  function drawStar(x, y, r, alpha) {
    ctx.save();
    ctx.translate(x, y);
    ctx.globalCompositeOperation = 'screen';
    
    // 1. 核心亮斑
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.3, 0, Math.PI * 2);
    ctx.fill();

    // 2. 柔和光晕
    const grd = ctx.createRadialGradient(0, 0, r*0.2, 0, 0, r*1.8);
    grd.addColorStop(0, `rgba(255, 240, 200, ${alpha * 0.6})`);
    grd.addColorStop(1, `rgba(255, 240, 200, 0)`);
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(0, 0, r*1.8, 0, Math.PI * 2);
    ctx.fill();

    // 3. 十字星芒 (细长)
    ctx.strokeStyle = `rgba(255, 255, 240, ${alpha * 0.8})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-r*1.6, 0); ctx.lineTo(r*1.6, 0);
    ctx.moveTo(0, -r*1.6); ctx.lineTo(0, r*1.6);
    ctx.stroke();

    // 4. 对角星芒 (短且淡)
    ctx.strokeStyle = `rgba(255, 255, 240, ${alpha * 0.4})`;
    ctx.lineWidth = 1;
    ctx.rotate(Math.PI / 4);
    ctx.beginPath();
    ctx.moveTo(-r*0.8, 0); ctx.lineTo(r*0.8, 0);
    ctx.moveTo(0, -r*0.8); ctx.lineTo(0, r*0.8);
    ctx.stroke();

    ctx.restore();
  }

  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
