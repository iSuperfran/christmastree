<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />
  <title>Merry Christmas</title>
  <style>
    /* 强制黑色背景，防止闪白 */
    html, body { margin:0; height:100%; background-color: #000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }
    
    /* 底部文字样式：增加发光外阴影，确保在黑色背景下清晰 */
    .caption {
      position: fixed; left: 0; right: 0;
      bottom: 8%; /* 稍微抬高 */
      text-align: center;
      pointer-events: none; user-select: none;
      z-index: 10;
    }
    .caption span {
      display: inline-block;
      font-size: clamp(32px, 8vw, 60px);
      font-family: "Snell Roundhand", "Brush Script MT", "Segoe Script", cursive;
      color: #fff;
      text-shadow: 0 0 10px rgba(255,200,100,0.8), 0 0 20px rgba(255,100,50,0.4);
      transform: rotate(-2deg);
      letter-spacing: 1px;
    }

    /* 顶部提示 */
    .hint {
      position: fixed; top: 15px; left: 0; right: 0;
      text-align: center;
      color: rgba(255,255,255,0.4);
      font-size: 12px;
      font-family: sans-serif;
      pointer-events: none;
    }
  </style>
</head>
<body>

<canvas id="c"></canvas>
<div class="hint">拖动旋转 · 滚轮/双指捏合散开</div>
<div class="caption"><span>Merry Christmas</span></div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false }); // 关闭透明通道，提升性能且背景更黑

  // 基础数学工具
  const clamp = (x,a,b) => Math.max(a, Math.min(b, x));
  const rand = (a,b) => a + Math.random() * (b - a);
  const lerp = (a,b,t) => a + (b - a) * t;

  // 屏幕适配
  let W, H, cx, cy, minD;
  const DPR = Math.min(2.5, window.devicePixelRatio || 1); // 限制DPR防止发热

  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W * DPR;
    canvas.height = H * DPR;
    ctx.scale(DPR, DPR);
    cx = W / 2;
    cy = H / 2;
    minD = Math.min(W, H);
  }
  window.addEventListener('resize', resize);
  resize();

  // ================= 交互状态 =================
  let yaw = 0, pitch = -0.2; // 初始视角
  let targetYaw = 0, targetPitch = -0.2;
  let scatter = 0, targetScatter = 0; // 0=树, 1=散开

  // 鼠标/触摸拖拽逻辑
  let isDragging = false, lastX = 0, lastY = 0;
  
  const onDown = (x, y) => { isDragging = true; lastX = x; lastY = y; };
  const onMove = (x, y) => {
    if (!isDragging) return;
    const dx = x - lastX;
    const dy = y - lastY;
    lastX = x; lastY = y;
    targetYaw += dx * 0.005;
    targetPitch += dy * 0.005;
    targetPitch = clamp(targetPitch, -1, 0.5); // 限制上下视角
  };
  const onUp = () => { isDragging = false; };

  canvas.addEventListener('mousedown', e => onDown(e.clientX, e.clientY));
  window.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
  window.addEventListener('mouseup', onUp);

  canvas.addEventListener('touchstart', e => {
    if(e.touches.length === 1) onDown(e.touches[0].clientX, e.touches[0].clientY);
  }, {passive: false});
  canvas.addEventListener('touchmove', e => {
    if(e.touches.length === 1) { e.preventDefault(); onMove(e.touches[0].clientX, e.touches[0].clientY); }
  }, {passive: false});
  window.addEventListener('touchend', onUp);

  // 滚轮控制散开
  canvas.addEventListener('wheel', e => {
    targetScatter += Math.sign(e.deltaY) * 0.1;
    targetScatter = clamp(targetScatter, 0, 1);
  }, {passive: true});

  // 双指缩放控制散开
  let initDist = 0, initScatter = 0;
  canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      initDist = Math.hypot(dx, dy);
      initScatter = targetScatter;
    }
  });
  canvas.addEventListener('touchmove', e => {
    if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const dist = Math.hypot(dx, dy);
      const delta = (dist - initDist) / 200; 
      // 捏合是变小(dist变小)，我们希望粒子散开还是聚拢？
      // 逻辑：捏合=散开(类似把东西挤碎)，张开=还原。或者反之。
      // 这里设定：双指张开(放大) -> 聚拢(0)，双指捏合(缩小) -> 散开(1)
      targetScatter = clamp(initScatter - delta, 0, 1);
      e.preventDefault();
    }
  });

  // ================= 粒子系统 =================
  const N = 2400; // 粒子数量，太多会卡，2400在手机上足够密集
  const particles = [];

  // 初始化粒子（螺旋结构）
  function init() {
    for (let i = 0; i < N; i++) {
      // 0 到 1 的分布，稍微偏向底部
      const t = Math.pow(Math.random(), 0.8); 
      
      // 树高和底半径
      const h = 300; 
      const maxR = 120;
      
      const y = -h/2 + t * h; // y轴坐标
      
      // 螺旋半径：越往上越小，呈圆锥状
      const rBase = (1 - t) * maxR;
      // 加一点随机噪点，形成“边缘不清晰”
      const r = rBase + rand(-15, 15); 

      // 螺旋角度：随高度旋转
      const turns = 6; 
      const angle = t * Math.PI * 2 * turns + rand(0, 0.5);

      const x = Math.cos(angle) * r;
      const z = Math.sin(angle) * r;

      // 散开的目标位置 (模拟宇宙大爆炸/星尘)
      // 随机分布在球体表面附近
      const sDir = Math.random() * Math.PI * 2;
      const sR = rand(150, 400);
      const sx = Math.cos(sDir) * sR;
      const sy = rand(-300, 300);
      const sz = Math.sin(sDir) * sR;

      // 颜色属性：0=冷色(顶部)，1=暖色(底部)
      // 顶部加一点冷色，底部金光
      const colorMix = 1 - t; 

      particles.push({
        x, y, z,          // 树形态坐标
        sx, sy, sz,       // 散开形态坐标
        colorMix,         // 颜色因子
        size: rand(0.8, 2.5), // 基础大小
        blink: rand(0, Math.PI * 2), // 闪烁相位
        blinkSpeed: rand(2, 5)       // 闪烁速度
      });
    }
  }
  init();

  // ================= 渲染循环 =================
  function draw() {
    // 1. 缓动更新参数
    yaw += (targetYaw - yaw) * 0.1;
    pitch += (targetPitch - pitch) * 0.1;
    scatter += (targetScatter - scatter) * 0.1;
    
    // 自动轻微旋转 (增加梦幻感)
    const autoRot = performance.now() * 0.0003;
    const finalYaw = yaw + autoRot;

    // 2. 清空背景 (纯黑)
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, W, H);

    // 3. 计算所有粒子投影
    const pData = [];
    const focal = 800; // 焦距
    
    // 预计算旋转矩阵
    const cy_cos = Math.cos(finalYaw), cy_sin = Math.sin(finalYaw);
    const cx_cos = Math.cos(pitch), cx_sin = Math.sin(pitch);

    for (let i = 0; i < N; i++) {
      const p = particles[i];

      // 插值计算当前位置 (树 <-> 散开)
      // 使用平滑插值 smoothstep
      const s = scatter * scatter * (3 - 2 * scatter);
      let px = p.x + (p.sx - p.x) * s;
      let py = p.y + (p.sy - p.y) * s;
      let pz = p.z + (p.sz - p.z) * s;

      // 旋转 Y 轴
      let x1 = px * cy_cos - pz * cy_sin;
      let z1 = pz * cy_cos + px * cy_sin;
      
      // 旋转 X 轴
      let y2 = py * cx_cos - z1 * cx_sin;
      let z2 = z1 * cx_cos + py * cx_sin;

      // 投影
      // 摄像机向后拉一点 (z2 + 600)
      const depth = z2 + 600;
      if (depth < 50) continue; // 裁剪太近的

      const scale = focal / depth;
      const screenX = cx + x1 * scale;
      const screenY = cy + y2 * scale * 1.05; // 稍微拉长一点y轴

      // 闪烁计算
      const time = performance.now() * 0.001;
      const shimmer = Math.sin(time * p.blinkSpeed + p.blink); 
      // 亮度范围 0.3 ~ 1.0 (保证最低亮度，防止看不见)
      const alpha = 0.3 + 0.7 * (shimmer * 0.5 + 0.5);

      pData.push({ x: screenX, y: screenY, z: depth, size: p.size * scale, colorMix: p.colorMix, alpha });
    }

    // 按深度排序，虽然 additive blending 不严格需要，但有助于处理遮挡感
    pData.sort((a, b) => b.z - a.z);

    // 4. 绘制 (关键：使用 lighter 混合模式)
    ctx.globalCompositeOperation = 'lighter'; // 变亮叠加模式，越叠越亮

    for (let i = 0; i < pData.length; i++) {
      const p = pData[i];
      
      // 颜色逻辑：混合 金色(255, 200, 50) 和 冰蓝(100, 200, 255)
      // 增加亮度基数，确保黑底上可见
      const r = Math.floor(lerp(100, 255, p.colorMix));
      const g = Math.floor(lerp(200, 220, p.colorMix));
      const b = Math.floor(lerp(255, 100, p.colorMix));
      
      const color = `rgba(${r}, ${g}, ${b}, ${p.alpha})`;

      // 绘制光点
      // 为了性能和效果，这里直接画实心圆，利用 globalCompositeOperation 做发光
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();

      // 偶尔绘制大光晕 (模拟星尘质感)
      if (i % 15 === 0) {
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${p.alpha * 0.15})`; // 非常淡的大圈
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * 6, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // 5. 绘制顶部的星星 (高亮)
    if (scatter < 0.8) {
      // 计算树顶坐标
      const topY = -150 - 10; // 树顶高度
      // 简单投影逻辑同上
      let tx = 0, ty = topY, tz = 0;
      let tx1 = tx * cy_cos - tz * cy_sin;
      let tz1 = tz * cy_cos + tx * cy_sin;
      let ty2 = ty * cx_cos - tz1 * cx_sin;
      let tz2 = tz1 * cx_cos + ty * cx_sin;
      const tDepth = tz2 + 600;
      const tScale = focal / tDepth;
      const tScreenX = cx + tx1 * tScale;
      const tScreenY = cy + ty2 * tScale * 1.05;

      // 随着散开消失
      const starAlpha = 1 - smoothstep(0.5, 1, scatter);
      
      if (starAlpha > 0.01) {
        drawStar(tScreenX, tScreenY, tScale * 15, starAlpha);
      }
    }

    requestAnimationFrame(draw);
  }

  // 辅助函数：平滑阶梯
  function smoothstep(min, max, value) {
    var x = Math.max(0, Math.min(1, (value-min)/(max-min)));
    return x*x*(3 - 2*x);
  }

  // 绘制亮星
  function drawStar(x, y, r, alpha) {
    ctx.save();
    ctx.translate(x, y);
    ctx.globalCompositeOperation = 'lighter';
    
    // 核心亮白
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.4, 0, Math.PI * 2);
    ctx.fill();

    // 十字光芒
    ctx.strokeStyle = `rgba(255, 255, 200, ${alpha * 0.8})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-r*1.5, 0); ctx.lineTo(r*1.5, 0);
    ctx.moveTo(0, -r*1.5); ctx.lineTo(0, r*1.5);
    ctx.stroke();

    // 外部辉光
    const grd = ctx.createRadialGradient(0, 0, r*0.2, 0, 0, r*2);
    grd.addColorStop(0, `rgba(255, 220, 100, ${alpha * 0.5})`);
    grd.addColorStop(1, `rgba(255, 200, 100, 0)`);
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(0, 0, r*2, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
