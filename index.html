<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />
  <title>Merry Christmas</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }
    .caption{
      position: fixed; left:0; right:0;
      bottom: clamp(26px, 7.5vh, 68px);
      text-align:center;
      pointer-events:none; user-select:none;
      mix-blend-mode: screen;
      filter: drop-shadow(0 0 14px rgba(255,220,190,.28))
              drop-shadow(0 0 28px rgba(120,190,255,.14));
    }
    .caption span{
      display:inline-block;
      font-size: clamp(28px, 6.2vw, 72px);
      font-weight: 500;
      color: rgba(255, 245, 235, 0.94);
      font-family:
        "Snell Roundhand","Segoe Script","Apple Chancery",
        "Lucida Handwriting","Brush Script MT","Comic Sans MS",cursive;
      transform: rotate(-1.2deg);
    }
    .hint{
      position: fixed; top: 12px; left: 12px;
      color: rgba(255,255,255,.58);
      font: 12px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      padding: 8px 10px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      user-select: none;
      pointer-events: none;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hint">拖动旋转｜滚轮/双指捏合：散开↔汇聚</div>
<div class="caption"><span>Merry Christmas</span></div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const smoothstep = (a,b,t)=> {
    t = clamp((t-a)/(b-a), 0, 1);
    return t*t*(3-2*t);
  };
  const rand = (a,b)=>a+Math.random()*(b-a);

  let W=0, H=0, DPR=1;
  function resize(){
    DPR = Math.max(1, Math.min(3, devicePixelRatio||1));
    W = Math.floor(innerWidth);
    H = Math.floor(innerHeight);
    canvas.width = Math.floor(W*DPR);
    canvas.height= Math.floor(H*DPR);
    canvas.style.width = W+"px";
    canvas.style.height= H+"px";
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // ===== Controls =====
  let yaw = 0.4, pitch = -0.18;
  let yawTarget = yaw, pitchTarget = pitch;

  let scatter = 0.0, scatterTarget = 0.0;

  // drag rotate (mouse + touch via pointer)
  let dragging=false, lastX=0, lastY=0;
  canvas.addEventListener('pointerdown', (e)=>{
    dragging=true;
    canvas.setPointerCapture?.(e.pointerId);
    lastX=e.clientX; lastY=e.clientY;
  }, {passive:true});
  canvas.addEventListener('pointermove', (e)=>{
    if(!dragging) return;
    const dx=e.clientX-lastX, dy=e.clientY-lastY;
    lastX=e.clientX; lastY=e.clientY;
    yawTarget += dx*0.0068;
    pitchTarget += dy*0.0048;
    pitchTarget = clamp(pitchTarget, -0.75, 0.35);
  }, {passive:true});
  canvas.addEventListener('pointerup', ()=>dragging=false, {passive:true});
  canvas.addEventListener('pointercancel', ()=>dragging=false, {passive:true});
  canvas.addEventListener('pointerleave', ()=>dragging=false, {passive:true});

  // wheel controls scatter
  canvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    scatterTarget = clamp(scatterTarget + Math.sign(e.deltaY)*0.07, 0, 1);
  }, {passive:false});

  // pinch controls scatter (touch)
  const touches = new Map();
  let pinchStartDist=0, pinchStartScatter=0;
  canvas.addEventListener('touchstart', (e)=>{
    for(const t of e.changedTouches) touches.set(t.identifier, {x:t.clientX,y:t.clientY});
    if(touches.size===2){
      const pts=[...touches.values()];
      pinchStartDist = Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
      pinchStartScatter = scatterTarget;
    }
  }, {passive:false});
  canvas.addEventListener('touchmove', (e)=>{
    e.preventDefault();
    for(const t of e.changedTouches) touches.set(t.identifier, {x:t.clientX,y:t.clientY});
    if(touches.size===2){
      const pts=[...touches.values()];
      const d = Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
      if(pinchStartDist>0){
        const k = (d-pinchStartDist) / Math.max(120, Math.min(W,H)*0.35);
        scatterTarget = clamp(pinchStartScatter + k, 0, 1);
      }
    }
  }, {passive:false});
  canvas.addEventListener('touchend', (e)=>{
    for(const t of e.changedTouches) touches.delete(t.identifier);
    if(touches.size<2) pinchStartDist=0;
  }, {passive:true});
  canvas.addEventListener('touchcancel', ()=>{
    touches.clear(); pinchStartDist=0;
  }, {passive:true});

  // ===== Tree params (tuned to be clearly visible) =====
  const N = 7000; // 更容易看见树形（仍能跑）
  const particles = new Array(N);

  function treeParams(){
    return { treeH: 1.65, baseR: 0.70 };
  }

  function initParticles(){
    const { treeH, baseR } = treeParams();
    for(let i=0;i<N;i++){
      const u = Math.pow(Math.random(), 0.62);
      const y = u * treeH;

      const coneR = (1 - (y/treeH)) * baseR;

      // 轮廓不清晰：边缘 fuzz，但别把 r 采到 0（否则集中成一根线）
      const edgeFuzz = coneR * rand(0.22, 0.62);
      const spiralTurns = 8.2;

      const theta = y/treeH * Math.PI*2*spiralTurns + rand(-0.55, 0.55);

      // 让粒子更倾向靠近“外轮廓”，这样更像树
      const rimBias = Math.pow(Math.random(), 0.22); // 越小越靠外
      const r = clamp(coneR * (0.58 + 0.45*rimBias) + rand(-edgeFuzz, edgeFuzz)*0.55, 0.02, baseR);

      const x = Math.cos(theta) * r;
      const z = Math.sin(theta) * r;

      // 极微扰动
      const j = 0.014;
      const jx = rand(-j,j), jy = rand(-j,j), jz = rand(-j,j);

      // 散开向量：宇宙星尘旋涡
      const so = {
        x: (Math.cos(theta*0.65) * rand(0.55, 1.55) + rand(-0.18,0.18)) * baseR,
        y: (rand(-0.45, 0.65)) * treeH,
        z: (Math.sin(theta*0.65) * rand(0.55, 1.55) + rand(-0.18,0.18)) * baseR
      };

      // 粒子尺寸：仍“细小”，但让一小部分更亮当高光点
      const isBright = Math.random() < 0.14;
      const size = rand(0.7, 1.9) * (isBright ? rand(1.2, 2.1) : 1.0);

      // 暖冷对比：底部更暖、顶部更冷一点
      const warm = clamp(0.62 - (y/treeH)*0.28 + rand(-0.10,0.10), 0, 1);

      const phase = rand(0, Math.PI*2);
      const speed = rand(0.7, 2.6);
      const tw = isBright ? rand(0.8, 1.4) : rand(0.25, 1.0);

      particles[i] = { base:{x:x+jx,y:y+jy,z:z+jz}, scatter:so, size, warm, phase, speed, tw, isBright };
    }
  }
  initParticles();

  // ===== 3D math =====
  function rotateY(p,a){
    const ca=Math.cos(a), sa=Math.sin(a);
    return { x: p.x*ca + p.z*sa, y:p.y, z: -p.x*sa + p.z*ca };
  }
  function rotateX(p,a){
    const ca=Math.cos(a), sa=Math.sin(a);
    return { x:p.x, y:p.y*ca - p.z*sa, z:p.y*sa + p.z*ca };
  }

  // perspective projection (tuned: closer camera + stronger focal => tree fills ~3/4)
  function project(p){
    const camZ = 1.65; // 更近 => 更大更清晰
    const z = p.z + camZ;
    const f = 900;     // 更强透视
    const s = f / z;
    const cx = W*0.5;
    const cy = H*0.54; // 稍微下移，留出顶部星星与底部文字
    return {
      x: cx + p.x * s * (Math.min(W,H)/880),
      y: cy - (p.y - 0.10) * s * (Math.min(W,H)/880),
      s, z
    };
  }

  function rgba(r,g,b,a){ return `rgba(${r|0},${g|0},${b|0},${a})`; }
  function colorFor(warm, a){
    const cool = 1-warm;
    const r = lerp(95, 255, warm) + lerp(35, 0, warm);
    const g = lerp(150, 235, warm) + lerp(40,  18, cool);
    const b = lerp(255, 205, warm) + lerp(35,  85, cool);
    return rgba(r,g,b,a);
  }

  function drawBackdrop(){
    ctx.clearRect(0,0,W,H);

    // very subtle ambient glow behind the tree center (still black overall)
    const cx=W*0.5, cy=H*0.46;
    const R=Math.min(W,H)*0.70;
    const g = ctx.createRadialGradient(cx,cy, 8, cx,cy, R);
    g.addColorStop(0, 'rgba(140,200,255,0.070)');
    g.addColorStop(0.50, 'rgba(255,190,140,0.030)');
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // reduce vignette strength to avoid killing visibility
    const v = ctx.createRadialGradient(cx,cy, R*0.30, cx,cy, R*1.05);
    v.addColorStop(0, 'rgba(0,0,0,0)');
    v.addColorStop(1, 'rgba(0,0,0,0.78)');
    ctx.fillStyle = v;
    ctx.fillRect(0,0,W,H);
  }

  function drawStar(x,y,baseR,intensity){
    const bloomR = baseR * lerp(8.0, 13.0, intensity);
    const glow = ctx.createRadialGradient(x,y, 0.5, x,y, bloomR);
    glow.addColorStop(0, 'rgba(255,245,210,0.82)');
    glow.addColorStop(0.18, 'rgba(255,240,200,0.34)');
    glow.addColorStop(1, 'rgba(255,240,200,0)');
    ctx.fillStyle = glow;
    ctx.beginPath(); ctx.arc(x,y,bloomR,0,Math.PI*2); ctx.fill();

    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(-Math.PI/12);
    ctx.globalCompositeOperation = 'screen';
    ctx.strokeStyle = 'rgba(255,250,230,0.72)';
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(-bloomR*0.9,0); ctx.lineTo(bloomR*0.9,0);
    ctx.moveTo(0,-bloomR*0.9); ctx.lineTo(0,bloomR*0.9);
    ctx.stroke();

    const spikes=5, outer=baseR*2.2, inner=baseR*0.9;
    ctx.rotate(Math.PI/5);
    ctx.beginPath();
    for(let i=0;i<spikes;i++){
      let a=i*Math.PI*2/spikes;
      ctx.lineTo(Math.cos(a)*outer, Math.sin(a)*outer);
      a += Math.PI/spikes;
      ctx.lineTo(Math.cos(a)*inner, Math.sin(a)*inner);
    }
    ctx.closePath();
    ctx.fillStyle='rgba(255,250,235,0.98)';
    ctx.shadowColor='rgba(255,220,160,0.90)';
    ctx.shadowBlur=22*intensity;
    ctx.fill();
    ctx.restore();
    ctx.globalCompositeOperation = 'source-over';
  }

  let t0 = performance.now();
  function frame(now){
    const t = (now - t0) / 1000;

    yaw = lerp(yaw, yawTarget, 0.12);
    pitch = lerp(pitch, pitchTarget, 0.12);
    scatter = lerp(scatter, scatterTarget, 0.10);

    drawBackdrop();

    // gentle auto motion
    const yawAnim = yaw + Math.sin(t*0.25)*0.10;

    // scale
    const scale = Math.min(W,H) * 0.60;

    // compute + sort
    const pts = new Array(N);

    for(let i=0;i<N;i++){
      const p = particles[i];

      // flowing dust motion
      const flow = 0.030 * Math.sin(t*0.95 + p.phase);
      let wx = p.base.x + flow*Math.cos(p.phase*1.7);
      let wy = p.base.y + flow*0.25;
      let wz = p.base.z + flow*Math.sin(p.phase*1.7);

      const drift = 0.22 * Math.sin(t*0.35 + p.phase);
      const dx = p.scatter.x + drift*Math.cos(p.phase);
      const dy = p.scatter.y + drift*0.30;
      const dz = p.scatter.z + drift*Math.sin(p.phase);

      const s = smoothstep(0,1,scatter);
      wx = lerp(wx, wx + dx, s);
      wy = lerp(wy, wy + dy, s);
      wz = lerp(wz, wz + dz, s);

      let P = {x:wx, y:wy, z:wz};
      P = rotateY(P, yawAnim);
      P = rotateX(P, pitch);
      P.x *= scale; P.y *= scale; P.z *= scale;

      const pr = project(P);

      // depth fade (less aggressive)
      const depthFade = clamp(1.35 - pr.z/3.1, 0, 1);

      const twinkle = 0.35 + (Math.sin(t*p.speed + p.phase)*0.5+0.5) * p.tw;

      const topBoost = smoothstep(0.70, 1.02, p.base.y / treeParams().treeH);
      const brightBoost = p.isBright ? 0.10 : 0.0;

      // IMPORTANT: brighter alpha so you can actually see the tree
      const alpha = (0.18 + 0.38*twinkle + 0.14*topBoost + brightBoost) * depthFade;

      const r = p.size * (0.65 + 0.75*twinkle) * clamp(pr.s, 0.55, 1.9);

      pts[i] = { x:pr.x, y:pr.y, z:pr.z, r, a:alpha, warm:p.warm, tw:twinkle, isBright:p.isBright };
    }

    pts.sort((a,b)=> b.z - a.z);

    ctx.save();
    ctx.globalCompositeOperation = 'screen';

    // slight exposure lift (keeps black background, makes glow readable)
    ctx.fillStyle = 'rgba(60,90,130,0.045)';
    ctx.fillRect(0,0,W,H);

    for(const q of pts){
      if(q.a <= 0.002) continue;

      const bloom = q.r * (5.2 + q.tw*4.2);
      const g = ctx.createRadialGradient(q.x,q.y, 0.2, q.x,q.y, bloom);
      g.addColorStop(0, colorFor(q.warm, q.a*1.05));
      g.addColorStop(0.18, colorFor(q.warm, q.a*0.45));
      g.addColorStop(1, colorFor(q.warm, 0));

      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(q.x, q.y, bloom, 0, Math.PI*2);
      ctx.fill();

      // core
      ctx.fillStyle = colorFor(q.warm, q.a*0.22);
      ctx.beginPath();
      ctx.arc(q.x, q.y, q.r, 0, Math.PI*2);
      ctx.fill();
    }

    ctx.restore();

    // star at top
    const { treeH } = treeParams();
    let top = { x:0, y:treeH + 0.02, z:0 };
    top = rotateY(top, yawAnim);
    top = rotateX(top, pitch);
    top.x *= scale; top.y *= scale; top.z *= scale;
    const tp = project(top);

    const starPulse = 0.65 + 0.35*Math.sin(t*2.2);
    drawStar(tp.x, tp.y, 2.2, clamp(0.95 + 0.65*starPulse, 0.95, 1.6));

    // ground haze
    const gx=W*0.5, gy=H*0.73, gr=Math.min(W,H)*0.46;
    const ground = ctx.createRadialGradient(gx,gy, 30, gx,gy, gr);
    ground.addColorStop(0, 'rgba(255,230,200,0.020)');
    ground.addColorStop(0.38,'rgba(120,190,255,0.016)');
    ground.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = ground;
    ctx.fillRect(0,0,W,H);

    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
