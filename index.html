<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Christmas Tree</title>
    <!-- 引入优雅的草书字体 -->
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000000; /* 深邃纯黑背景 */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        /* 预加载字体防止画布渲染延迟 */
        .font-loader {
            font-family: 'Great Vibes', cursive;
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="font-loader">Merry Christmas</div>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let particles = [];
        const particleCount = 1200; // 粒子数量
        let time = 0;

        // 调整画布大小
        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // 颜色配置：冷暖对比 (青色, 紫色, 金色)
        const colors = [
            'hsla(180, 100%, 70%, ',  // Neon Cyan
            'hsla(280, 100%, 70%, ',  // Neon Purple
            'hsla(45, 100%, 70%, '    // Warm Gold
        ];

        class Particle {
            constructor() {
                this.reset();
                this.y = Math.random() * height; // 初始随机高度，避免一开始都在底部
            }

            reset() {
                this.angle = Math.random() * Math.PI * 2;
                this.radiusScale = Math.random();
                this.y = height + Math.random() * 100; // 从底部下方生成
                this.speed = 1 + Math.random() * 1.5;
                this.size = Math.random() * 2.5; // 粒子大小错落
                this.colorBase = colors[Math.floor(Math.random() * colors.length)];
                this.alpha = 0;
                this.sparklePhase = Math.random() * Math.PI;
                // 螺旋参数
                this.spiralOffset = Math.random() * Math.PI; 
            }

            update() {
                // 向上移动
                this.y -= this.speed;

                // 简单的闪烁逻辑
                this.sparklePhase += 0.1;
                this.alpha = 0.3 + Math.abs(Math.sin(this.sparklePhase)) * 0.7;

                // 如果超出顶部，重置到底部
                const treeTop = height * 0.2;
                if (this.y < treeTop) {
                    this.reset();
                    this.y = height * 0.9; // 重置到底部附近
                    this.alpha = 0; // 渐入
                }
            }

            draw() {
                // 计算树的形状：圆锥体
                // 随着y向上（值变小），半径变小
                const treeHeight = height * 0.7;
                const treeBottom = height * 0.9;
                const progress = (treeBottom - this.y) / treeHeight; // 0 (bottom) to 1 (top)
                
                if (progress < 0) return; // 低于树底不画

                // 核心螺旋逻辑
                // 半径随高度减小，呈非线性曲线更加优雅
                const currentRadius = (1 - Math.pow(progress, 0.8)) * (width < 600 ? 120 : 250);
                
                // 角度随高度旋转，形成螺旋
                const rotation = time * 0.5 + progress * 10 + this.spiralOffset;
                
                const x = width / 2 + Math.cos(rotation) * currentRadius;
                // 加入一点正弦波动，模拟3D透视的z轴压缩感
                const zOffset = Math.sin(rotation) * (currentRadius * 0.3); 
                const y = this.y + zOffset;

                // 越靠近中心/顶部，越亮
                const finalAlpha = this.alpha * (1 - Math.pow(progress, 4)) * (progress > 0.9 ? 0 : 1); 

                ctx.beginPath();
                // 粒子绘制
                ctx.fillStyle = this.colorBase + finalAlpha + ')';
                // 模拟景深：前面的大，后面的小
                const perspective = (Math.sin(rotation) + 2) / 3; 
                ctx.arc(x, y, this.size * perspective * (1-progress*0.5), 0, Math.PI * 2);
                ctx.fill();
                
                // 添加极弱的光晕
                if (Math.random() > 0.95) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.colorBase + '1)';
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        }

        // 初始化粒子
        for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle());
        }

        function drawStar() {
            const treeTopY = height * 0.2;
            const cx = width / 2;
            const cy = treeTopY;

            ctx.save();
            ctx.translate(cx, cy);
            
            // 耀眼光芒（多层叠加）
            const gradient = ctx.createRadialGradient(0, 0, 1, 0, 0, 30);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 200, 0.8)');
            gradient.addColorStop(0.5, 'rgba(0, 242, 255, 0.3)'); // 青色外晕
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            ctx.fillStyle = gradient;
            ctx.globalCompositeOperation = 'lighter';
            
            // 绘制中心光团
            ctx.beginPath();
            ctx.arc(0, 0, 30, 0, Math.PI * 2);
            ctx.fill();

            // 绘制十字星芒
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#fff';
            
            // 旋转星芒
            ctx.rotate(time * 0.5);
            
            for(let j=0; j<2; j++) {
                ctx.rotate(Math.PI / 2);
                ctx.beginPath();
                ctx.moveTo(-2, 0);
                ctx.lineTo(0, -25 - Math.sin(time * 5)*5); // 伸缩效果
                ctx.lineTo(2, 0);
                ctx.lineTo(0, 25 + Math.sin(time * 5)*5);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawText() {
            const fontSize = Math.min(width, height) * 0.08;
            ctx.font = `${fontSize}px "Great Vibes", cursive`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const textX = width / 2;
            const textY = height * 0.88;

            // 文字发光效果 (霓虹质感)
            ctx.save();
            
            // 阴影/光晕层
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'rgba(0, 195, 255, 0.8)'; // 青色光晕
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillText('Merry Christmas', textX, textY);

            // 再次叠加暖色，营造冷暖对比
            ctx.shadowBlur = 5;
            ctx.shadowColor = 'rgba(255, 215, 0, 0.6)'; // 金色微光
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillText('Merry Christmas', textX, textY);
            
            ctx.restore();
        }

        function animate() {
            // 背景清除，带一点透明度制造拖尾效果（模拟流光质感）
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; 
            // 如果想要纯黑背景不带拖尾，改成: ctx.clearRect(0, 0, width, height); 
            // 这里的 fillRect 能让粒子运动产生丝滑的视觉残留
            ctx.fillRect(0, 0, width, height);

            // 使用 lighter 混合模式实现发光叠加
            ctx.globalCompositeOperation = 'lighter';

            time += 0.02;

            // 绘制树主体粒子
            particles.forEach(p => {
                p.update();
                p.draw();
            });

            // 恢复正常混合模式绘制顶部星星和文字
            ctx.globalCompositeOperation = 'source-over';
            drawStar();
            
            // 再次切换混合模式让文字更亮
            drawText();

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
