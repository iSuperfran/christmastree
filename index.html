<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />
  <title>Merry Christmas</title>
  <style>
    /* 纯黑背景，无边距 */
    html, body { 
      margin: 0; 
      height: 100%; 
      background-color: #000; 
      overflow: hidden; 
    }
    
    canvas { 
      display: block; 
      width: 100vw; 
      height: 100vh; 
    }
    
    /* 底部文字：手写风格，柔和发光 */
    .caption {
      position: fixed; 
      left: 0; 
      right: 0;
      bottom: 10%; /* 黄金分割位置 */
      text-align: center;
      pointer-events: none; 
      user-select: none;
      z-index: 10;
    }
    
    .caption span {
      display: inline-block;
      font-size: clamp(36px, 9vw, 72px);
      font-family: "Snell Roundhand", "Brush Script MT", "Segoe Script", "Apple Chancery", cursive;
      color: rgba(255, 248, 235, 0.9); /* 奶白色 */
      text-shadow: 
        0 0 10px rgba(255, 200, 100, 0.6),
        0 0 20px rgba(255, 100, 50, 0.3);
      transform: rotate(-3deg); /* 微微倾斜更具手写感 */
      letter-spacing: 2px;
    }
  </style>
</head>
<body>

<canvas id="c"></canvas>
<div class="caption"><span>Merry Christmas</span></div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false }); 

  // 基础工具
  const rand = (a, b) => a + Math.random() * (b - a);
  const lerp = (a, b, t) => a + (b - a) * t;

  let W, H, cx, cy;
  // 限制 DPR 既保证清晰度又不让手机发烫
  const DPR = Math.min(2.0, window.devicePixelRatio || 1);

  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W * DPR;
    canvas.height = H * DPR;
    ctx.scale(DPR, DPR);
    cx = W / 2;
    cy = H / 2;
  }
  window.addEventListener('resize', resize);
  resize();

  // ================= 粒子系统配置 =================
  const N = 2600; // 粒子数量：足够密集形成模糊轮廓
  const particles = [];

  function init() {
    for (let i = 0; i < N; i++) {
      // 0 ~ 1，越接近 1 越高
      const t = Math.pow(Math.random(), 0.7); 
      
      const h = 380;   // 树高
      const maxR = 140; // 底部最大半径
      
      const y = -h/2 + t * h; 
      
      // 螺旋半径：线性减小，形成圆锥
      const rBase = (1 - t) * maxR;
      // 关键：增加随机偏移 (Fuzziness)，制造“边缘不清晰”的星尘感
      const r = rBase + rand(-18, 18) * (1 - t * 0.5); 
      
      // 螺旋角度
      const turns = 7; 
      const angle = t * Math.PI * 2 * turns + rand(0, 0.5);

      const x = Math.cos(angle) * r;
      const z = Math.sin(angle) * r;

      // 颜色混合：0 = 冰蓝(未来感), 1 = 金色(温馨)
      // 底部偏暖，顶部偏冷，中间随机混合
      const colorMix = 1 - t + rand(-0.15, 0.15);

      particles.push({
        baseX: x, baseY: y, baseZ: z, // 原始坐标
        colorMix: Math.max(0, Math.min(1, colorMix)),
        size: rand(0.5, 2.0),         // 粒子大小错落
        blinkOffset: rand(0, Math.PI * 2), // 闪烁相位
        blinkSpeed: rand(1, 3)        // 闪烁速度
      });
    }
  }
  init();

  // ================= 渲染循环 =================
  function draw() {
    // 自动时间流
    const time = performance.now() * 0.001;
    
    // 极其缓慢的自转，展示3D感
    const autoYaw = time * 0.2; 
    const pitch = -0.15; // 稍微俯视一点点，最美视角

    // 清空背景 (纯黑)
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, W, H);

    const pData = [];
    const focal = 900; // 长焦镜头，画面更平整唯美
    
    const cy_cos = Math.cos(autoYaw), cy_sin = Math.sin(autoYaw);
    const cx_cos = Math.cos(pitch), cx_sin = Math.sin(pitch);

    // 1. 计算粒子
    for (let i = 0; i < N; i++) {
      const p = particles[i];

      // 微弱的流动感：y轴上轻微上下浮动
      const flow = Math.sin(time * 2 + p.baseY * 0.05) * 1.5;
      let py = p.baseY + flow;
      
      // 旋转
      let x1 = p.baseX * cy_cos - p.baseZ * cy_sin;
      let z1 = p.baseZ * cy_cos + p.baseX * cy_sin;
      let y2 = py * cx_cos - z1 * cx_sin;
      let z2 = z1 * cx_cos + py * cx_sin;

      // 投影
      const depth = z2 + 700; // 相机距离
      if (depth < 50) continue; 

      const scale = focal / depth;
      const screenX = cx + x1 * scale;
      const screenY = cy + y2 * scale * 1.05; // 稍微拉长一点点，更修长

      // 闪烁逻辑：正弦波呼吸
      const shimmer = Math.sin(time * p.blinkSpeed + p.blinkOffset); 
      // 亮度范围：0.3 (暗) ~ 1.0 (亮)
      const alpha = 0.3 + 0.7 * (shimmer * 0.5 + 0.5);

      pData.push({ 
        x: screenX, y: screenY, z: depth, 
        size: p.size * scale, 
        colorMix: p.colorMix, 
        alpha 
      });
    }

    // 按深度排序（虽然是光点，排序后叠加效果更自然）
    pData.sort((a, b) => b.z - a.z);

    // 2. 绘制粒子
    // 使用 Screen 模式：像光线一样叠加，柔和不刺眼
    ctx.globalCompositeOperation = 'screen'; 

    for (let i = 0; i < pData.length; i++) {
      const p = pData[i];
      
      // 唯美调色板
      // Cool (顶部/未来感): R:100 G:220 B:255 (Cyan/Blue)
      // Warm (底部/温馨): R:255 G:200 B:120 (Gold/Amber)
      const r = Math.floor(lerp(100, 255, p.colorMix));
      const g = Math.floor(lerp(220, 200, p.colorMix));
      const b = Math.floor(lerp(255, 120, p.colorMix));
      
      // 画光晕 (虚)
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${p.alpha * 0.3})`; 
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * 3.0, 0, Math.PI * 2);
      ctx.fill();

      // 画核心 (实)
      ctx.fillStyle = `rgba(255, 255, 255, ${p.alpha * 0.9})`; 
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * 0.7, 0, Math.PI * 2);
      ctx.fill();
    }

    // 3. 绘制顶部高亮星星
    const topY = -190 - 10; 
    let tx = 0, ty = topY, tz = 0;
    // 星星也要跟随旋转
    let tx1 = tx * cy_cos - tz * cy_sin;
    let tz1 = tz * cy_cos + tx * cy_sin;
    let ty2 = ty * cx_cos - tz1 * cx_sin;
    let tz2 = tz1 * cx_cos + ty * cx_sin;

    const tDepth = tz2 + 700;
    const tScale = focal / tDepth;
    const tScreenX = cx + tx1 * tScale;
    const tScreenY = cy + ty2 * tScale * 1.05;
    
    // 星星呼吸
    const starPulse = 0.8 + 0.2 * Math.sin(time * 3);
    drawStar(tScreenX, tScreenY, tScale * 16, starPulse);

    requestAnimationFrame(draw);
  }

  // 绘制精致的十字星
  function drawStar(x, y, r, alpha) {
    ctx.save();
    ctx.translate(x, y);
    ctx.globalCompositeOperation = 'screen';
    
    // 核心亮斑
    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.4, 0, Math.PI * 2);
    ctx.fill();

    // 大光晕
    const grd = ctx.createRadialGradient(0, 0, r*0.2, 0, 0, r*2.0);
    grd.addColorStop(0, `rgba(255, 245, 220, ${alpha * 0.5})`);
    grd.addColorStop(1, `rgba(255, 245, 220, 0)`);
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(0, 0, r*2.0, 0, Math.PI * 2);
    ctx.fill();

    // 细长的十字光芒
    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-r*2.0, 0); ctx.lineTo(r*2.0, 0); // 横
    ctx.moveTo(0, -r*2.0); ctx.lineTo(0, r*2.0); // 竖
    ctx.stroke();

    // 柔和的对角光芒
    ctx.strokeStyle = `rgba(255, 240, 200, ${alpha * 0.5})`;
    ctx.lineWidth = 1;
    ctx.rotate(Math.PI / 4);
    ctx.beginPath();
    ctx.moveTo(-r*1.0, 0); ctx.lineTo(r*1.0, 0);
    ctx.moveTo(0, -r*1.0); ctx.lineTo(0, r*1.0);
    ctx.stroke();

    ctx.restore();
  }

  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
